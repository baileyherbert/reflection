{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+","tags":false},"docs":[{"location":"","text":"","title":"Introduction"},{"location":"#welcome","text":"<p>This is the documentation for <code>@baileyherbert/reflection</code>. This library allows you to perform reflection at runtime for classes, methods, properties, and parameters. It also makes it simple to work with metadata and design types.</p> <pre><code>import { ReflectionClass } from '@baileyherbert/reflection';\nimport { ClassName } from './exampleClass';\n\nconst reflect = new ReflectionClass(ClassName);\n\n// Instantiate new instances\nconst instance = reflect.create(...args);\n\n// Manage class metadata\n// These are available for methods, parameters, and properties too!\nreflect.hasMetadata('key');\nreflect.getMetadata('key');\n\n// Get methods\nreflect.getMethods().map(method =&gt; method.name);\nreflect.getMethod('constructor').getParameters().map(param =&gt; param.getType());\n\n// Get properties\nreflect.getProperties().filter(prop =&gt; prop.hasMetadata('example'));\n</code></pre>","title":"Welcome!"},{"location":"#getting_started","text":"<p>Install the package into your project:</p> <pre><code>npm install @baileyherbert/reflection\n</code></pre> <p>Then configure your <code>tsconfig.json</code> file if you want metadata and type reflection:</p> <pre><code>{\n    \"compilerOptions\": {\n        \"experimentalDecorators\": true,\n        \"emitDecoratorMetadata\": true,\n    }\n}\n</code></pre>","title":"Getting started"},{"location":"decorators/Meta/","text":"<p>This is a \"smart decorator\" that can be used to set metadata on classes, methods, and parameters. You can also build upon this decorator to easily create your own metadata decorators without any of the associated complexity.</p>","title":"Meta Decorator"},{"location":"decorators/Meta/#variations","text":"","title":"Variations"},{"location":"decorators/Meta/#variation:smart","text":"<p>Returns a metadata decorator that can be applied to classes, methods, and parameters. This is the one you'll want to use in practice \u2013 the rest are mainly for building upon.</p> <p> Examples</p> <pre><code>@Meta('key', 'value')\nexport class Example {\n\n    @Meta('key', 'value')\n    public method(@Meta('key', 'value') param: any) {\n\n    }\n\n}\n</code></pre>","title":"<code>@Meta(key: any, value: any)</code>"},{"location":"decorators/Meta/#variation:class","text":"<p>Returns a metadata decorator that can be applied to only classes.</p> <p> Examples</p> <pre><code>@Meta.Class('key', 'value')\nexport class Example {\n\n}\n</code></pre>","title":"<code>@Meta.Class(key: any, value: any)</code>"},{"location":"decorators/Meta/#variation:method","text":"<p>Returns a metadata decorator that can be applied to only methods.</p> <p> Examples</p> <pre><code>export class Example {\n\n    @Meta.Method('key', 'value')\n    public method() {\n\n    }\n\n}\n</code></pre>","title":"<code>@Meta.Method(key: any, value: any)</code>"},{"location":"decorators/Meta/#variation:property","text":"<p>Returns a metadata decorator that can be applied to only properties.</p> <p> Examples</p> <pre><code>export class Example {\n\n    @Meta.Property('key', 'value')\n    public prop: string;\n\n}\n</code></pre>","title":"<code>@Meta.Property(key: any, value: any)</code>"},{"location":"decorators/Meta/#variation:parameter","text":"<p>Returns a metadata decorator that can be applied to only parameters.</p> <p> Examples</p> <pre><code>export class Example {\n\n    public method(@Meta.Parameter('key', 'value') param: any) {\n\n    }\n\n}\n</code></pre>","title":"<code>@Meta.Parameter(key: any, value: any)</code>"},{"location":"decorators/Meta/#custom_decorators","text":"<p>You can create a custom meta decorator using the existing <code>@Meta</code> decorators as a basis.</p> <pre><code>export const SmartDecorator = Meta('key', 'value');\nexport const ClassDecorator = Meta.Class('key', 'value');\nexport const MethodDecorator = Meta.Method('key', 'value');\nexport const ParameterDecorator = Meta.Parameter('key', 'value');\n</code></pre> <p>You can also create a decorator that accepts parameters:</p> <pre><code>export const VariableDecorator = (value: string) =&gt; Meta('key', value);\n</code></pre> <p>You can then use these constants like normal decorators.</p> <pre><code>@SmartDecorator\n@ClassDecorator\n@VariableDecorator('value')\nexport class Example {\n\n    @MethodDecorator\n    @VariableDecorator('another value')\n    public method(@ParameterDecorator param: any) {\n\n    }\n\n}\n</code></pre>","title":"Custom decorators"},{"location":"decorators/Reflectable/","text":"<p>Type reflection depends on type metadata being emitted by the TypeScript compiler. However, the compiler does not emit type metadata unless there is a decorator applied.</p> <p>In cases when you need to reflect on a class or method, and there are no decorators applied to it (or a parent implementation of it), then you can use the <code>@Reflectable</code> decorator.</p>","title":"Reflectable Decorator"},{"location":"decorators/Reflectable/#reflectable","text":"<p>A blank decorator that can be used to trigger metadata emit by <code>tsc</code> on a class or method. The parenthesis on this decorator are optional.</p> <pre><code>import { Reflectable } from '@baileyherbert/reflection';\n\n@Reflectable\nexport class Example {\n\n    @Reflectable\n    public method() {\n\n    }\n\n}\n</code></pre>","title":"<code>@Reflectable()</code>"},{"location":"enums/MethodFilter/","text":"","title":"<code>MethodFilter</code>"},{"location":"enums/MethodFilter/#description","text":"<p>Describes different features of methods for filtering.</p>","title":"Description"},{"location":"enums/MethodFilter/#import","text":"<pre><code>import { MethodFilter } from '@baileyherbert/reflection';\n</code></pre>","title":"Import"},{"location":"enums/MethodFilter/#values","text":"Name Value Description     <code>Static</code> <code>1</code> Filter methods that are static.   <code>Local</code> <code>2</code> Filter methods that are local (not static).   <code>Typed</code> <code>4</code> Filter methods that have type metadata available.   <code>Inherited</code> <code>8</code> Filter methods that are inherited from a parent class.   <code>Own</code> <code>16</code> Filter methods that are not inherited.","title":"Values"},{"location":"enums/ParameterFilter/","text":"","title":"<code>ParameterFilter</code>"},{"location":"enums/ParameterFilter/#description","text":"<p>Describes different features of parameters for filtering.</p>","title":"Description"},{"location":"enums/ParameterFilter/#import","text":"<pre><code>import { ParameterFilter } from '@baileyherbert/reflection';\n</code></pre>","title":"Import"},{"location":"enums/ParameterFilter/#values","text":"Name Value Description     <code>Meta</code> <code>1</code> Filter parameters that have reflection metadata available.   <code>WithDefault</code> <code>2</code> Filter parameters that have ES6 default values.   <code>WithoutDefault</code> <code>4</code> Filter parameters that don't have default values.   <code>PrimitiveType</code> <code>8</code> Filter parameters that expect a primitive type.   <code>NonPrimitiveType</code> <code>16</code> Filter parameters that have specific object or function types.   <code>KnownType</code> <code>32</code> Filter parameters that have specific, unambiguous types.   <code>UnknownType</code> <code>64</code> Filter parameters that have unknown or ambiguous types.","title":"Values"},{"location":"enums/PropertyFilter/","text":"","title":"<code>PropertyFilter</code>"},{"location":"enums/PropertyFilter/#description","text":"<p>Describes different features of properties for filtering.</p>","title":"Description"},{"location":"enums/PropertyFilter/#import","text":"<pre><code>import { PropertyFilter } from '@baileyherbert/reflection';\n</code></pre>","title":"Import"},{"location":"enums/PropertyFilter/#values","text":"Name Value Description     <code>Typed</code> <code>1</code> Filter properties that have type metadata available.   <code>Inherited</code> <code>2</code> Filter properties that are inherited from a parent class.   <code>Own</code> <code>4</code> Filter properties that are not inherited.","title":"Values"},{"location":"internals/parameter-metadata/","text":"","title":"Parameter Metadata"},{"location":"internals/parameter-metadata/#introduction","text":"<p>Parameter metadata can be stored in countless ways. This reflection library uses a specific format which enables the <code>getMetadata()</code> method to work on parameters.</p> <p>If you are writing your own decorators, consider invoking the <code>Meta.Parameter</code> function like below to easily set metadata in the correct structure.</p> <pre><code>import { Meta } from '@baileyherbert/reflection';\n\nexport function Decorator(target: Object, propertyKey: string | symbol, parameterIndex: number) {\n    Meta.Parameter('key', 'value')(target, propertyKey, parameterIndex);\n}\n</code></pre> <p>If your decorator only needs to set metadata, you can also directly wrap the <code>Meta.Parameter</code> function like below.</p> <pre><code>import { Meta } from '@baileyherbert/reflection';\n\n// With static data\nexport const Decorator = Meta.Parameter('key', 'value');\n\n// With variable data\nexport const Decorator = (value: string) =&gt; Meta.Parameter('key', value);\n</code></pre> <p>The rest of this page will discuss how metadata is structured internally for this library in case of advanced usage.</p>","title":"Introduction"},{"location":"internals/parameter-metadata/#storage_structure","text":"<ul> <li>Parameter metadata is stored on the parent method under the <code>\"reflection:params\"</code> key</li> <li>The value of this key must be <code>undefined</code> or an instance of <code>Array&lt;Map&lt;any, any&gt;&gt;</code><ul> <li>The array indices are the indices of the parameters</li> <li>The array values are <code>Map&lt;any, any&gt;</code> objects containing the metadata</li> </ul> </li> </ul> <p>Refer to the following code sample which sets metadata on a parameter just like the <code>@Meta.Parameter()</code> decorator:</p>","title":"Storage structure"},{"location":"internals/parameter-metadata/#example","text":"<pre><code>function ParameterMeta(metadataKey: any, metadataValue: any) {\n    return function(target: Object, propertyKey: string | symbol, parameterIndex: number) {\n            let parameters = Reflect.getOwnMetadata('reflection:params', target, propertyKey);\n\n            if (parameters === undefined) {\n                parameters = new Array&lt;Map&lt;any, any&gt;&gt;();\n                Reflect.defineMetadata('reflection:params', parameters, target, propertyKey);\n            }\n\n            if (!(parameterIndex in parameters)) {\n                parameters[parameterIndex] = new Map();\n            }\n\n            parameters[parameterIndex].set(metadataKey, metadataValue);\n    };\n}\n</code></pre>","title":"Example"},{"location":"reference/attributes/","text":"","title":"Attributes"},{"location":"reference/attributes/#introduction","text":"<p>Attributes are a new decorator concept exclusive to this library. Rather than define a decorator function which is simply invoked after the class is declared, attributes are entire classes that can be applied to your target classes, methods, properties, and parameters.</p> <p>Using reflection at runtime, you can retrieve instances of all attributes applied to classes and their members. You can then use their methods and access their data.</p> <p>Even if you don't need to retrieve instances at runtime, attributes can be a quick and simple way to create a metadata decorator that works on specific or all member types.</p>","title":"Introduction"},{"location":"reference/attributes/#example","text":"","title":"Example"},{"location":"reference/attributes/#creating_an_attribute","text":"<p>The following code creates an <code>@Example()</code> attribute which can only be applied to classes. It sets metadata on the target class using a value passed into the constructor.</p> <pre><code>import { Attribute, AttributeClassEvent } from '@baileyherbert/reflection';\n\nexport const Example = Attribute.create(class extends Attribute {\n\n    public constructor(public message: string) {\n        super();\n    }\n\n    public override onClass(event: AttributeClassEvent&lt;Object&gt;) {\n        event.reflection.setMetadata('attr_message', this.message);\n    }\n\n});\n</code></pre>","title":"Creating an attribute"},{"location":"reference/attributes/#using_an_attribute","text":"<p>The attribute can then be used like any other decorator.</p> <pre><code>@Example('Hello world!')\nexport class MessageContainer {}\n</code></pre>","title":"Using an attribute"},{"location":"reference/attributes/#retrieving_an_attribute","text":"<p>You can also use reflection to retrieve the attribute and access its <code>message</code> property. You can access all public properties and methods on the attribute's underlying class.</p> <pre><code>const reflection = new ReflectionClass(MessageContainer);\nconst example = reflection.getAttribute(Example)!;\n\nconsole.log(example.message) // 'Hello world!'\n</code></pre>","title":"Retrieving an attribute"},{"location":"reference/attributes/#attribute_classes","text":"<p>Attributes contain four methods which are invoked just like decorator functions would be. These methods are special, however. Unless you override them, the attribute won't be applicable to those target types.</p> <p>Review the following example which shows all four method signatures. In this case, the attribute can be applied to all four target types.</p> <pre><code>const Example = Attribute.create(class extends Attribute {\n\n    public override onClass(event: AttributeClassEvent&lt;Object&gt;) {\n\n    }\n\n    public override onMethod(event: AttributeMethodEvent&lt;Object&gt;) {\n\n    }\n\n    public override onParameter(event: AttributeParameterEvent&lt;Object&gt;) {\n\n    }\n\n    public override onProperty(event: AttributePropertyEvent&lt;Object&gt;) {\n\n    }\n\n});\n</code></pre> <p>Each of the <code>event</code> objects passed into these methods contains the decorator parameters, as well as a reflection instance which you can use to analyze and set metadata on the target.</p>","title":"Attribute classes"},{"location":"reference/attributes/#restricting_types","text":"<p>You can use the generic in <code>Attribute&lt;T&gt;</code> to restrict what kinds of classes the attribute can be applied to. The attribute event objects will also need to have their generics updated.</p> <pre><code>const Example = Attribute.create(class extends Attribute&lt;SampleClass&gt; {\n\n    public override onClass(event: AttributeClassEvent&lt;SampleClass&gt;) {\n\n    }\n\n    public override onMethod(event: AttributeMethodEvent&lt;SampleClass&gt;) {\n\n    }\n\n}\n</code></pre> <p>Now the attribute can only be applied to <code>SampleClass</code> or its children.</p> <pre><code>@Example() // OK\nclass SampleClass {}\n\n@Example() // ERROR!\nclass AnotherClass {}\n</code></pre>","title":"Restricting types"},{"location":"reference/attributes/#registry","text":"<p>This library exports an <code>attributes</code> registry where all attribute instances are registered across the application. You typically will want to use the <code>getAttribute()</code> and <code>getAttributes()</code> methods on reflection objects, but you could use this instead.</p> <pre><code>import { attributes } from '@baileyherbert/reflection';\n\n@Example()\nclass SampleClass {}\n\n// Get the 'Example' attribute instance above\nconst attr = attributes.getFromClass(SampleClass, Example)[0];\n</code></pre>","title":"Registry"},{"location":"reference/classes/","text":"","title":"Class reflection"},{"location":"reference/classes/#creating_an_instance","text":"<p>To get started with reflection, create a <code>ReflectionClass</code> instance and pass a reference to a class constructor. You can also pass an instance of a class and the constructor will be inferred.</p> <pre><code>const reflect = new ReflectionClass(ExampleClass);\nconst reflect = new ReflectionClass(new ExampleClass());\n</code></pre>","title":"Creating an instance"},{"location":"reference/classes/#properties","text":"","title":"Properties"},{"location":"reference/classes/#property:name","text":"<p>The name of the class as a string.</p>","title":"<code>name: string</code>"},{"location":"reference/classes/#property:parent","text":"<p>The reflection instance for the parent class or <code>undefined</code> if the class has no parent.</p>","title":"<code>parent: ReflectionClass?</code>"},{"location":"reference/classes/#property:target","text":"<p>A reference to the underlying class constructor.</p>","title":"<code>target: Type&lt;T&gt;</code>"},{"location":"reference/classes/#property:prototype","text":"<p>A reference to the underlying class prototype.</p>","title":"<code>prototype: Object</code>"},{"location":"reference/classes/#retrieving_methods","text":"","title":"Retrieving methods"},{"location":"reference/classes/#method:getMethods","text":"<p>Returns an array of <code>ReflectionMethod</code> instances that describe each method on the class.</p> <p> Parameters</p>    Name Type Description Default     <code>filter</code> <code>MethodFilter</code>, <code>undefined</code> An optional filter to choose what kind of methods are returned. <code>undefined</code>    <p> Examples</p> <p><pre><code>// Iterate over all methods\nfor (const method of reflect.getMethods()) {}\n</code></pre> <pre><code>// Filter static methods\nconst staticMethods = reflect.getMethods(MethodFilter.Static);\n</code></pre> <pre><code>// Multiple filters (AND)\nconst staticOwnMethods = reflect.getMethods(\n    MethodFilter.Static | MethodFilter.Own\n);\n</code></pre></p>","title":"<code>getMethods(filter?: MethodFilter)</code>"},{"location":"reference/classes/#method:getMethod","text":"<p>Returns the <code>ReflectionMethod</code> instance for a method matching the given name. Returns <code>undefined</code> when no matching method is found.</p> <p> Parameters</p>    Name Type Description Default     <code>name</code> <code>string</code> The name of the method to search for. required   <code>filter</code> <code>MethodFilter</code>, <code>undefined</code> An optional filter to choose what kind of methods are checked. <code>undefined</code>    <p> Examples</p> <pre><code>const method = reflect.getMethod('methodName');\nmethod?.invoke(o);\n</code></pre>","title":"<code>getMethod(name: string, filter?: MethodFilter)</code>"},{"location":"reference/classes/#method:hasMethod","text":"<p>Returns <code>true</code> if the class has a method matching the given name.</p> <p> Parameters</p>    Name Type Description Default     <code>name</code> <code>string</code> The name of the method to search for. required   <code>filter</code> <code>MethodFilter</code>, <code>undefined</code> An optional filter to use when checking for a matching method. <code>undefined</code>    <p> Examples</p> <pre><code>reflect.hasMethod('staticMethodName') // true\nreflect.hasMethod('staticMethodName', MethodFilter.Local) // false\n</code></pre>","title":"<code>hasMethod(name: string, filter?: MethodFilter)</code>"},{"location":"reference/classes/#method:getConstructorMethod","text":"<p>Returns a <code>ReflectionMethod</code> instance representing the <code>constructor</code> method for the class. The constructor method is guaranteed to exist, even if one is not explicitly defined.</p> <p> Examples</p> <pre><code>// These return the same exact object\nreflect.getConstructorMethod();\nreflect.getMethod('constructor');\n</code></pre>","title":"<code>getConstructorMethod()</code>"},{"location":"reference/classes/#retrieving_properties","text":"<p>Warning</p> <p>Due to the way property metadata is stored, properties will not be visible to reflection unless you use the <code>@Meta()</code> or <code>@Meta.Property()</code> decorators in some way.</p> <p>This is because, while property metadata is stored in the same way as methods, there is no way to iterate over properties on the prototype like you can with methods. This means there's no way for reflection to identify what properties exist.</p> <p>To get around this problem, the <code>@Meta</code> decorators store a set of known property names on the class under the <code>reflection:properties</code> key.</p>","title":"Retrieving properties"},{"location":"reference/classes/#method:getProperties","text":"<p>Returns an array of <code>ReflectionProperty</code> instances that describe each known property on the class.</p> <p> Parameters</p>    Name Type Description Default     <code>filter</code> <code>PropertyFilter</code>, <code>undefined</code> An optional filter to choose what kind of properties are returned. <code>undefined</code>    <p> Examples</p> <p><pre><code>// Iterate over all properties\nfor (const property of reflect.getProperties()) {}\n</code></pre> <pre><code>// Filter own properties (not from a parent class)\nconst ownProperties = reflect.getProperties(PropertyFilter.Own);\n</code></pre></p>","title":"<code>getProperties(filter?: PropertyFilter)</code>"},{"location":"reference/classes/#method:getProperty","text":"<p>Returns the <code>ReflectionProperty</code> instance for a property matching the given name. Returns <code>undefined</code> when no matching property is found.</p> <p> Parameters</p>    Name Type Description Default     <code>name</code> <code>string</code> The name of the property to search for. required   <code>filter</code> <code>PropertyFilter</code>, <code>undefined</code> An optional filter to choose what kind of properties are checked. <code>undefined</code>    <p> Examples</p> <pre><code>const property = reflect.getProperty('propertyName');\nconst value = property?.getMetadata('key');\n</code></pre>","title":"<code>getProperty(name: string, filter?: PropertyFilter)</code>"},{"location":"reference/classes/#method:hasProperty","text":"<p>Returns <code>true</code> if the class has a property matching the given name.</p> <p> Parameters</p>    Name Type Description Default     <code>name</code> <code>string</code> The name of the property to search for. required   <code>filter</code> <code>PropertyFilter</code>, <code>undefined</code> An optional filter to use when checking for a matching property. <code>undefined</code>    <p> Examples</p> <pre><code>reflect.hasProperty('propertyName')\n</code></pre>","title":"<code>hasProperty(name: string, filter?: PropertyFilter)</code>"},{"location":"reference/classes/#retrieving_attributes","text":"<p>This library has a powerful alternative to decorators called attributes. You can use the following methods to retrieve attribute instances that have been applied to a class.</p>","title":"Retrieving attributes"},{"location":"reference/classes/#method:getAttributes","text":"<p>Returns an array of instances of the specified attribute on the class. When the <code>attribute</code> argument is not supplied, it will return all attributes on the class.</p> <p> Parameters</p>    Name Type Description Default     <code>attribute</code> <code>IAttribute&lt;any&gt;</code> A reference to the attribute function. <code>undefined</code>    <p> Examples</p> <pre><code>for (const attribute of reflect.getAttributes(ExampleAttribute)) {\n    // Do something\n}\n</code></pre>","title":"<code>getAttributes(attribute?: IAttribute&lt;any&gt;)</code>"},{"location":"reference/classes/#method:getAttribute","text":"<p>Returns an instance of the specified attribute on the class or <code>undefined</code> if not found. Only the last instance (the instance declared in the code last) will be returned.</p> <p> Parameters</p>    Name Type Description Default     <code>attribute</code> <code>IAttribute&lt;any&gt;</code> A reference to the attribute function. required    <p> Examples</p> <pre><code>const latest = reflect.getAttributes(ExampleAttribute);\n</code></pre>","title":"<code>getAttribute(attribute: IAttribute&lt;any&gt;)</code>"},{"location":"reference/classes/#method:hasAttribute","text":"<p>Returns true if the class has any attributes of the specified type applied.</p> <p> Parameters</p>    Name Type Description Default     <code>attribute</code> <code>IAttribute&lt;any&gt;</code> A reference to the attribute function. required    <p> Examples</p> <pre><code>if (reflect.hasAttributes(ExampleAttribute)) {\n    // Do something!\n}\n</code></pre>","title":"<code>hasAttribute(attribute: IAttribute&lt;any&gt;)</code>"},{"location":"reference/classes/#managing_metadata","text":"<p>These methods use the <code>reflect-metadata</code> library under the hood. You can use the <code>@Meta</code> decorator built into this package, or refer to the TypeScript Handbook on Decorators, to set metadata on your classes.</p>","title":"Managing metadata"},{"location":"reference/classes/#method:getMetadata","text":"<p>Returns the value of a metadata key on the class.</p> <p> Parameters</p>    Name Type Description Default     <code>key</code> <code>any</code> The key to look for. This must be identical to the key you originally used to store the data. required","title":"<code>getMetadata(key: any)</code>"},{"location":"reference/classes/#method:getAllMetadata","text":"<p>Returns a <code>Map</code> containing all metadata on the class.</p> <p> Examples</p> <pre><code>const meta = reflect.getAllMetadata();\nconst value = meta.get('key');\n</code></pre>","title":"<code>getAllMetadata()</code>"},{"location":"reference/classes/#method:setMetadata","text":"<p>Sets the value of a metadata key on the class.</p> <p> Parameters</p>    Name Type Description Default     <code>key</code> <code>any</code> The key to set data for. required   <code>value</code> <code>any</code> The data to store under the key. Existing data will be overwritten. required","title":"<code>setMetadata(key: any, value: any)</code>"},{"location":"reference/classes/#method:hasMetadata","text":"<p>Returns <code>true</code> if this class has metadata matching the given key.</p> <p> Parameters</p>    Name Type Description Default     <code>key</code> <code>any</code> The key to look for. This must be identical to the key you originally used to store the data. required","title":"<code>hasMetadata(key: any)</code>"},{"location":"reference/classes/#ancestry","text":"","title":"Ancestry"},{"location":"reference/classes/#method:getHierarchy","text":"<p>Returns an array of <code>ReflectionClass</code> instances representing the hierarchy of the current class. The first element in the array will be the topmost parent class, and the last element will be the current class.</p> <p>For classes with no parents, this will return an array containing only the current class.</p> <p> Examples</p> <p><pre><code>class Vehicle {}\nclass Car extends Vehicle {}\nclass Hatchback extends Car {}\n\nconst reflection = new ReflectionClass(Hatchback);\nconst hierarchy = reflection.getHierachy();\n</code></pre> The above <code>hierarchy</code> variable will be an array that looks like the following. <pre><code>[\n    ReflectionClass(Vehicle),\n    ReflectionClass(Car),\n    ReflectionClass(Hatchback)\n]\n</code></pre></p>","title":"<code>getHierarchy()</code>"},{"location":"reference/classes/#method:hastype","text":"<p>Returns <code>true</code> if this class has a class within its hierarchy, including itself, which matches the given class constructor type.</p> <p> Parameters</p>    Name Type Description Default     <code>type</code> <code>Type&lt;any&gt;</code> A reference to the class to check against. required    <p> Examples</p> <pre><code>class Vehicle {}\nclass Car extends Vehicle {}\nclass Hatchback extends Car {}\n\nconst reflection = new ReflectionClass(Hatchback);\n\nreflection.hasType(Car) // true\nreflection.hasType(Vehicle) // true\nreflection.hasType(Hatchback) // true - includes itself\n</code></pre>","title":"<code>hasType(type: Type&lt;any&gt;)</code>"},{"location":"reference/classes/#method:hasAncestorType","text":"<p>Returns <code>true</code> if this class has a class within its hierarchy, not including itself, which matches the given class constructor type.</p> <p> Parameters</p>    Name Type Description Default     <code>type</code> <code>Type&lt;any&gt;</code> A reference to the class to check against. required    <p> Examples</p> <pre><code>class Vehicle {}\nclass Car extends Vehicle {}\nclass Hatchback extends Car {}\n\nconst reflection = new ReflectionClass(Hatchback);\n\nreflection.hasAncestorType(Car) // true\nreflection.hasAncestorType(Vehicle) // true\nreflection.hasAncestorType(Hatchback) // false - doesn't include itself\n</code></pre>","title":"<code>hasAncestorType(type: Type&lt;any&gt;)</code>"},{"location":"reference/classes/#creating_instances","text":"","title":"Creating instances"},{"location":"reference/classes/#method:create","text":"<p>Creates a new instance of the class with the given constructor arguments.</p> <p> Parameters</p>    Name Type Description Default     <code>args</code> <code>any[]</code> An array of constructor arguments. <code>[]</code>    <p> Examples</p> <pre><code>class Hatchback {\n    public constructor(public name: string, public year: number) {\n\n    }\n}\n\nconst reflection = new ReflectionClass(Hatchback);\nconst instance = reflection.create(['Honda Civic', 2020]);\n</code></pre>","title":"<code>create(args?: any[])</code>"},{"location":"reference/methods/","text":"","title":"Method reflection"},{"location":"reference/methods/#retrieving_an_instance","text":"<p>Retrieve an instance from the parent class using <code>getMethod()</code> or <code>getMethods()</code>. It is not possible to manually instantiate a reflection method.</p>","title":"Retrieving an instance"},{"location":"reference/methods/#properties","text":"","title":"Properties"},{"location":"reference/methods/#property:name","text":"<p>The name of the method as a string.</p>","title":"<code>name: string</code>"},{"location":"reference/methods/#property:class","text":"<p>The class that this method belongs to.</p>","title":"<code>class: ReflectionClass</code>"},{"location":"reference/methods/#property:isConstructor","text":"<p>Whether or not the method is the constructor for the class.</p>","title":"<code>isConstructor: boolean</code>"},{"location":"reference/methods/#property:isStatic","text":"<p>Whether or not the method is static.</p>","title":"<code>isStatic: boolean</code>"},{"location":"reference/methods/#property:isTyped","text":"<p>Whether or not the method has type metadata available from TypeScript.</p>","title":"<code>isTyped: boolean</code>"},{"location":"reference/methods/#property:prototype","text":"<p>A reference to the underlying class prototype.</p>","title":"<code>prototype: Object</code>"},{"location":"reference/methods/#invoking_methods","text":"","title":"Invoking methods"},{"location":"reference/methods/#method:getFunction","text":"<p>Returns a reference to the method on the class prototype. In most cases, you won't want to use this and should instead use the <code>invoke()</code> or <code>getClosure()</code> methods.</p> <p> Examples</p> <pre><code>const fn = method.getFunction();\nfn.call(instance, ...args);\n</code></pre>","title":"<code>getFunction()</code>"},{"location":"reference/methods/#method:getClosure","text":"<p>Returns an anonymous function that invokes the method on the given object.</p> <p> Parameters</p>    Name Type Description Default     <code>object</code> <code>T</code>, <code>null</code>, <code>undefined</code> An instance of the class to invoke the method on. For static methods, pass <code>null</code> or <code>undefined</code>. <code>undefined</code>    <p> Examples</p> <pre><code>const fn = method.getClosure(instance);\nfn(...args);\n</code></pre>","title":"<code>getClosure(object?: T | null)</code>"},{"location":"reference/methods/#method:invoke","text":"<p>Invokes the method on the given object with optional arguments.</p> <p> Parameters</p>    Name Type Description Default     <code>object</code> <code>T</code>, <code>null</code>, <code>undefined</code> An instance of the class to invoke the method on. For static methods, pass <code>null</code> or <code>undefined</code>. <code>undefined</code>   <code>...args</code> <code>any[]</code> Optional arguments to pass to the method.     <p> Examples</p> <p><pre><code>method.invoke(instance);\n</code></pre> <pre><code>method.invoke(instance, 'Arguments here!', true);\n</code></pre> <pre><code>method.invoke(null, 'Static methods');\n</code></pre></p>","title":"<code>invoke(object?: T | null, ...args: any[])</code>"},{"location":"reference/methods/#managing_parameters","text":"","title":"Managing parameters"},{"location":"reference/methods/#method:getParameters","text":"<p>Returns an array of <code>ReflectionParameter</code> instances which describe each parameter from the method.</p> <p> Parameters</p>    Name Type Description Default     <code>filter</code> <code>ParameterFilter</code>, <code>undefined</code> An optional filter to choose what kind of parameters are returned. <code>undefined</code>    <p> Examples</p> <p><pre><code>// Iterate over all parameters\nfor (const param of reflect.getParameters()) {}\n</code></pre> <pre><code>// Filter parameters that don't have default values\nconst requiredParams = reflect.getParameters(\n    ParameterFilter.WithoutDefault\n);\n</code></pre> <pre><code>// Multiple filters (AND)\n// This will find all parameters with a non-generic type that have metadata\nconst knownNonPrimitives = reflect.getMethods(\n    ParameterFilter.Meta | ParameterFilter.NonPrimitiveType\n);\n</code></pre></p>","title":"<code>getParameters(filter?: ParameterFilter)</code>"},{"location":"reference/methods/#method:getParameter","text":"<p>Returns a <code>ReflectionParameter</code> instance for the specified parameter. Returns <code>undefined</code> if there is no matching parameter.</p> <p> Parameters</p>    Name Type Description Default     <code>name</code> <code>string</code> The name of the parameter to search for. required   <code>filter</code> <code>ParameterFilter</code>, <code>undefined</code> An optional filter to choose what kind of parameters are checked. <code>undefined</code>    <p> Examples</p> <pre><code>const param = method.getParameter('paramName');\n</code></pre>","title":"<code>getParameter(name: string, filter?: ParameterFilter)</code>"},{"location":"reference/methods/#method:getParameter:index","text":"<p>Returns a <code>ReflectionParameter</code> instance for the parameter at the specified index. Returns <code>undefined</code> if there is no matching parameter.</p> <p> Parameters</p>    Name Type Description Default     <code>index</code> <code>number</code> The index to retrieve (zero-based). required    <p> Examples</p> <pre><code>const param = method.getParameter(0);\n</code></pre>","title":"<code>getParameter(index: number)</code>"},{"location":"reference/methods/#method:hasParameter","text":"<p>Returns <code>true</code> if the method contains a parameter with the specified name, optionally with a filter applied.</p> <p> Parameters</p>    Name Type Description Default     <code>name</code> <code>string</code> The name of the parameter to search for. required   <code>filter</code> <code>ParameterFilter</code>, <code>undefined</code> An optional filter to choose what kind of parameters are checked. <code>undefined</code>    <p> Examples</p> <pre><code>if (method.hasParameter('paramName')) {\n    // ...\n}\n</code></pre>","title":"<code>hasParameter(name: string, filter?: ParameterFilter)</code>"},{"location":"reference/methods/#return_types","text":"","title":"Return types"},{"location":"reference/methods/#method:getReturnType","text":"<p>Returns the method's return type as it was defined by the TypeScript compiler. When type information is not available, or when the method does not return anything, <code>undefined</code> will be returned instead.</p> <ul> <li>When a function can return multiple types, this will return a generic <code>Object</code></li> <li>When a function returns a class instance, this will return the class constructor</li> </ul> <p> Examples</p> <pre><code>if (method.getReturnType() === String) {\n    const str = method.invoke(o);\n}\n</code></pre>","title":"<code>getReturnType()</code>"},{"location":"reference/methods/#method:getReturnTypeString","text":"<p>Returns the method's return type as a string. This will be identical to what the <code>typeof</code> operator would produce.</p> <p> Examples</p> <pre><code>if (method.getReturnTypeString() === 'string') {\n    const str = method.invoke(o);\n}\n</code></pre>","title":"<code>getReturnTypeString()</code>"},{"location":"reference/methods/#retrieving_attributes","text":"<p>This library has a powerful alternative to decorators called attributes. You can use the following methods to retrieve attribute instances that have been applied to a method.</p>","title":"Retrieving attributes"},{"location":"reference/methods/#method:getAttributes","text":"<p>Returns an array of instances of the specified attribute on the method. When the <code>attribute</code> argument is not supplied, it will return all attributes on the method.</p> <p> Parameters</p>    Name Type Description Default     <code>attribute</code> <code>IAttribute&lt;any&gt;</code> A reference to the attribute function. <code>undefined</code>    <p> Examples</p> <pre><code>for (const attribute of method.getAttributes(ExampleAttribute)) {\n    // Do something\n}\n</code></pre>","title":"<code>getAttributes(attribute?: IAttribute&lt;any&gt;)</code>"},{"location":"reference/methods/#method:getAttribute","text":"<p>Returns an instance of the specified attribute on the method or <code>undefined</code> if not found. Only the last instance (the instance declared in the code last) will be returned.</p> <p> Parameters</p>    Name Type Description Default     <code>attribute</code> <code>IAttribute&lt;any&gt;</code> A reference to the attribute function. required    <p> Examples</p> <pre><code>const latest = method.getAttributes(ExampleAttribute);\n</code></pre>","title":"<code>getAttribute(attribute: IAttribute&lt;any&gt;)</code>"},{"location":"reference/methods/#method:hasAttribute","text":"<p>Returns true if the method has any attributes of the specified type applied.</p> <p> Parameters</p>    Name Type Description Default     <code>attribute</code> <code>IAttribute&lt;any&gt;</code> A reference to the attribute function. required    <p> Examples</p> <pre><code>if (method.hasAttributes(ExampleAttribute)) {\n    // Do something!\n}\n</code></pre>","title":"<code>hasAttribute(attribute: IAttribute&lt;any&gt;)</code>"},{"location":"reference/methods/#managing_metadata","text":"<p>These methods use the <code>reflect-metadata</code> library under the hood. You can use the <code>@Meta</code> decorator built into this package, or refer to the TypeScript Handbook on Decorators, to set metadata on your methods.</p>","title":"Managing metadata"},{"location":"reference/methods/#method:getMetadata","text":"<p>Returns the value of a metadata key on the method.</p> <p> Parameters</p>    Name Type Description Default     <code>key</code> <code>any</code> The key to look for. This must be identical to the key you originally used to store the data. required","title":"<code>getMetadata(key: any)</code>"},{"location":"reference/methods/#method:getAllMetadata","text":"<p>Returns a <code>Map</code> containing all metadata on the method.</p> <p> Examples</p> <pre><code>const meta = reflect.getAllMetadata();\nconst value = meta.get('key');\n</code></pre>","title":"<code>getAllMetadata()</code>"},{"location":"reference/methods/#method:setMetadata","text":"<p>Sets the value of a metadata key on the method.</p> <p> Parameters</p>    Name Type Description Default     <code>key</code> <code>any</code> The key to set data for. required   <code>value</code> <code>any</code> The data to store under the key. Existing data will be overwritten. required","title":"<code>setMetadata(key: any, value: any)</code>"},{"location":"reference/methods/#method:hasMetadata","text":"<p>Returns <code>true</code> if this method has metadata matching the given key.</p> <p> Parameters</p>    Name Type Description Default     <code>key</code> <code>any</code> The key to look for. This must be identical to the key you originally used to store the data. required","title":"<code>hasMetadata(key: any)</code>"},{"location":"reference/parameters/","text":"","title":"Parameter reflection"},{"location":"reference/parameters/#retrieving_an_instance","text":"<p>Retrieve an instance from the parent method using <code>getParameter()</code> or <code>getParameters()</code>. It is not possible to manually instantiate a reflection parameter.</p>","title":"Retrieving an instance"},{"location":"reference/parameters/#properties","text":"","title":"Properties"},{"location":"reference/parameters/#property:method","text":"<p>The <code>ReflectionMethod</code> instance that this parameter belongs to.</p>","title":"<code>method: ReflectionMethod</code>"},{"location":"reference/parameters/#property:index","text":"<p>The parameter index as an integer. The first parameter in a method will have the index <code>0</code>.</p>","title":"<code>index: number</code>"},{"location":"reference/parameters/#property:name","text":"<p>The name of the parameter.</p>","title":"<code>name: string</code>"},{"location":"reference/parameters/#property:hasDefault","text":"<p>Whether or not the parameter has an ES6 default value.</p>","title":"<code>hasDefault: boolean</code>"},{"location":"reference/parameters/#property:isPrimitiveType","text":"<p>Whether or not the parameter is a primitive type such as a <code>string</code>, <code>number</code>, <code>bigint</code>, <code>boolean</code>, <code>symbol</code>, or <code>undefined</code>. Please note that this does not include generic <code>object</code> types due to metadata limitations.</p>","title":"<code>isPrimitiveType: boolean</code>"},{"location":"reference/parameters/#property:isKnownType","text":"<p>Whether or not the parameter has a known and non-generic type. This will return false for generic objects, generic functions, <code>null</code>, and <code>undefined</code>.</p>","title":"<code>isKnownType: boolean</code>"},{"location":"reference/parameters/#property:isClassType","text":"<p>Whether or not the parameter accepts an instance of a class.</p>","title":"<code>isClassType: boolean</code>"},{"location":"reference/parameters/#parameter_type","text":"","title":"Parameter type"},{"location":"reference/parameters/#method:getType","text":"<p>Returns the parameters's expected type as it was defined by the TypeScript compiler. When type information is not available, or when the parameter does not define a type, <code>undefined</code> will be returned instead.</p> <ul> <li>When a parameter accepts multiple types, this will return a generic <code>Object</code></li> <li>When a parameter accepts a class instance, this will return the class constructor</li> </ul> <p> Examples</p> <pre><code>if (parameter.getType() === String) {}\nif (parameter.getType() === undefined) {}\n</code></pre>","title":"<code>getType()</code>"},{"location":"reference/parameters/#method:getTypeString","text":"<p>Returns the parameters's expected type as a string. This will be identical to what the <code>typeof</code> operator would produce.</p> <p> Examples</p> <pre><code>if (parameter.getTypeString() === 'string') {}\nif (parameter.getTypeString() === 'undefined') {}\n</code></pre>","title":"<code>getTypeString()</code>"},{"location":"reference/parameters/#retrieving_attributes","text":"<p>This library has a powerful alternative to decorators called attributes. You can use the following methods to retrieve attribute instances that have been applied to a parameter.</p>","title":"Retrieving attributes"},{"location":"reference/parameters/#method:getAttributes","text":"<p>Returns an array of instances of the specified attribute on the parameter. When the <code>attribute</code> argument is not supplied, it will return all attributes on the parameter.</p> <p> Parameters</p>    Name Type Description Default     <code>attribute</code> <code>IAttribute&lt;any&gt;</code> A reference to the attribute function. <code>undefined</code>    <p> Examples</p> <pre><code>for (const attribute of parameter.getAttributes(ExampleAttribute)) {\n    // Do something\n}\n</code></pre>","title":"<code>getAttributes(attribute?: IAttribute&lt;any&gt;)</code>"},{"location":"reference/parameters/#method:getAttribute","text":"<p>Returns an instance of the specified attribute on the parameter or <code>undefined</code> if not found. Only the last instance (the instance declared in the code last) will be returned.</p> <p> Parameters</p>    Name Type Description Default     <code>attribute</code> <code>IAttribute&lt;any&gt;</code> A reference to the attribute function. required    <p> Examples</p> <pre><code>const latest = parameter.getAttributes(ExampleAttribute);\n</code></pre>","title":"<code>getAttribute(attribute: IAttribute&lt;any&gt;)</code>"},{"location":"reference/parameters/#method:hasAttribute","text":"<p>Returns true if the parameter has any attributes of the specified type applied.</p> <p> Parameters</p>    Name Type Description Default     <code>attribute</code> <code>IAttribute&lt;any&gt;</code> A reference to the attribute function. required    <p> Examples</p> <pre><code>if (parameter.hasAttributes(ExampleAttribute)) {\n    // Do something!\n}\n</code></pre>","title":"<code>hasAttribute(attribute: IAttribute&lt;any&gt;)</code>"},{"location":"reference/parameters/#managing_metadata","text":"<p>These methods use the <code>reflect-metadata</code> library under the hood. You can use the <code>@Meta</code> decorator built into this package, or refer to the TypeScript Handbook on Decorators, to set metadata on your parameters.</p>  <p>Warning</p> <p>Parameter metadata is stored on the method in no particular format. It is therefore extremely important that you use the <code>@Meta()</code> or <code>@Meta.Parameter()</code> decorators in this package to set parameter metadata in a format that the below methods can understand.</p> <p>To learn more about the format we expect, and how to write your own compatible parameter decorators, check out the parameter metadata internals guide.</p>","title":"Managing metadata"},{"location":"reference/parameters/#method:getMetadata","text":"<p>Returns the value of a metadata key on the parameter.</p> <p> Parameters</p>    Name Type Description Default     <code>key</code> <code>any</code> The key to look for. This must be identical to the key you originally used to store the data. required","title":"<code>getMetadata(key: any)</code>"},{"location":"reference/parameters/#method:getAllMetadata","text":"<p>Returns a <code>Map</code> containing all metadata on the parameter.</p> <p> Examples</p> <pre><code>const meta = reflect.getAllMetadata();\nconst value = meta.get('key');\n</code></pre>","title":"<code>getAllMetadata()</code>"},{"location":"reference/parameters/#method:setMetadata","text":"<p>Sets the value of a metadata key on the parameter.</p> <p> Parameters</p>    Name Type Description Default     <code>key</code> <code>any</code> The key to set data for. required   <code>value</code> <code>any</code> The data to store under the key. Existing data will be overwritten. required","title":"<code>setMetadata(key: any, value: any)</code>"},{"location":"reference/parameters/#method:hasMetadata","text":"<p>Returns <code>true</code> if this parameter has metadata matching the given key.</p> <p> Parameters</p>    Name Type Description Default     <code>key</code> <code>any</code> The key to look for. This must be identical to the key you originally used to store the data. required","title":"<code>hasMetadata(key: any)</code>"},{"location":"reference/properties/","text":"","title":"Property reflection"},{"location":"reference/properties/#retrieving_an_instance","text":"<p>Retrieve an instance from the parent class using <code>getProperty()</code> or <code>getProperties()</code>. It is not possible to manually instantiate a reflection property.</p>","title":"Retrieving an instance"},{"location":"reference/properties/#properties","text":"","title":"Properties"},{"location":"reference/properties/#property:name","text":"<p>The name of the property as a string.</p>","title":"<code>name: string</code>"},{"location":"reference/properties/#property:class","text":"<p>The class that this property belongs to.</p>","title":"<code>class: ReflectionClass</code>"},{"location":"reference/properties/#property:isTyped","text":"<p>Whether or not the property has type metadata available from TypeScript.</p>","title":"<code>isTyped: boolean</code>"},{"location":"reference/properties/#property_type","text":"","title":"Property type"},{"location":"reference/properties/#method:getType","text":"<p>Returns the property's expected type as it was defined by the TypeScript compiler. When type information is not available, or when the property does not define a type, <code>undefined</code> will be returned instead.</p> <ul> <li>When a property accepts multiple types, this will return a generic <code>Object</code></li> <li>When a property accepts a class instance, this will return the class constructor</li> </ul> <p> Examples</p> <pre><code>if (property.getType() === String) {}\nif (property.getType() === undefined) {}\n</code></pre>","title":"<code>getType()</code>"},{"location":"reference/properties/#method:getTypeString","text":"<p>Returns the property's expected type as a string. This will be identical to what the <code>typeof</code> operator would produce.</p> <p> Examples</p> <pre><code>if (property.getTypeString() === 'string') {}\nif (property.getTypeString() === 'undefined') {}\n</code></pre>","title":"<code>getTypeString()</code>"},{"location":"reference/properties/#retrieving_attributes","text":"<p>This library has a powerful alternative to decorators called attributes. You can use the following methods to retrieve attribute instances that have been applied to a property.</p>","title":"Retrieving attributes"},{"location":"reference/properties/#method:getAttributes","text":"<p>Returns an array of instances of the specified attribute on the property. When the <code>attribute</code> argument is not supplied, it will return all attributes on the property.</p> <p> Parameters</p>    Name Type Description Default     <code>attribute</code> <code>IAttribute&lt;any&gt;</code> A reference to the attribute function. <code>undefined</code>    <p> Examples</p> <pre><code>for (const attribute of property.getAttributes(ExampleAttribute)) {\n    // Do something\n}\n</code></pre>","title":"<code>getAttributes(attribute?: IAttribute&lt;any&gt;)</code>"},{"location":"reference/properties/#method:getAttribute","text":"<p>Returns an instance of the specified attribute on the property or <code>undefined</code> if not found. Only the last instance (the instance declared in the code last) will be returned.</p> <p> Parameters</p>    Name Type Description Default     <code>attribute</code> <code>IAttribute&lt;any&gt;</code> A reference to the attribute function. required    <p> Examples</p> <pre><code>const latest = property.getAttributes(ExampleAttribute);\n</code></pre>","title":"<code>getAttribute(attribute: IAttribute&lt;any&gt;)</code>"},{"location":"reference/properties/#method:hasAttribute","text":"<p>Returns true if the property has any attributes of the specified type applied.</p> <p> Parameters</p>    Name Type Description Default     <code>attribute</code> <code>IAttribute&lt;any&gt;</code> A reference to the attribute function. required    <p> Examples</p> <pre><code>if (property.hasAttributes(ExampleAttribute)) {\n    // Do something!\n}\n</code></pre>","title":"<code>hasAttribute(attribute: IAttribute&lt;any&gt;)</code>"},{"location":"reference/properties/#managing_metadata","text":"<p>These methods use the <code>reflect-metadata</code> library under the hood. You can use the <code>@Meta</code> decorator built into this package, or refer to the TypeScript Handbook on Decorators, to set metadata on your properties.</p>","title":"Managing metadata"},{"location":"reference/properties/#method:getMetadata","text":"<p>Returns the value of a metadata key on the property.</p> <p> Parameters</p>    Name Type Description Default     <code>key</code> <code>any</code> The key to look for. This must be identical to the key you originally used to store the data. required","title":"<code>getMetadata(key: any)</code>"},{"location":"reference/properties/#method:getAllMetadata","text":"<p>Returns a <code>Map</code> containing all metadata on the property.</p> <p> Examples</p> <pre><code>const meta = reflect.getAllMetadata();\nconst value = meta.get('key');\n</code></pre>","title":"<code>getAllMetadata()</code>"},{"location":"reference/properties/#method:setMetadata","text":"<p>Sets the value of a metadata key on the property.</p> <p> Parameters</p>    Name Type Description Default     <code>key</code> <code>any</code> The key to set data for. required   <code>value</code> <code>any</code> The data to store under the key. Existing data will be overwritten. required","title":"<code>setMetadata(key: any, value: any)</code>"},{"location":"reference/properties/#method:hasMetadata","text":"<p>Returns <code>true</code> if this property has metadata matching the given key.</p> <p> Parameters</p>    Name Type Description Default     <code>key</code> <code>any</code> The key to look for. This must be identical to the key you originally used to store the data. required","title":"<code>hasMetadata(key: any)</code>"}]}